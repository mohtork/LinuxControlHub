import { storage } from './storage';
import { sshManager } from './ssh';
import { vulsIntegration } from './vuls-integration';
import { dockerVulsScanner } from './docker-vuls';
import { vulsRestClient } from './vuls-rest-client';
import path from 'path';
import { 
  InsertVulnerabilityScan,
  Task
} from '@shared/schema';

/**
 * Class for handling vulnerability scanning functionality
 * This implementation prefers using the Vuls service via REST API,
 * falls back to Docker-based Vuls scans when the service is unavailable,
 * and finally uses the simulated approach as a last resort.
 */
export class VulnerabilityScanner {
  private useDockerWhenAvailable: boolean = true;
  
  /**
   * Run a vulnerability scan on a server
   */
  async runScan(task: Task): Promise<void> {
    if (task.type !== 'vulnerability_scan' || !task.config) {
      throw new Error('Invalid task type for vulnerability scanning');
    }
    
    const serverId = task.serverId;
    
    if (!serverId) {
      throw new Error('Server ID is required for vulnerability scanning');
    }
    
    // Create a scan record in the database
    const scanInput: InsertVulnerabilityScan = {
      serverId,
      userId: task.createdById
    };
    
    const scan = await storage.createVulnerabilityScan(scanInput);
    
    // Update the scan with the taskId for proper linking
    await storage.updateVulnerabilityScan(scan.id, {
      taskId: task.id
    });
    
    try {
      // Update task status
      await storage.updateTask(task.id, { 
        status: 'running',
        startedAt: new Date()
      });
      
      // Update scan status
      await storage.updateVulnerabilityScan(scan.id, { 
        status: 'running'
      });
      
      const server = await storage.getServer(serverId);
      if (!server) {
        throw new Error(`Server with ID ${serverId} not found`);
      }
      
      console.log(`Starting vulnerability scan for server ${server.name} (${server.hostname})`);
      
      let vulnerabilities: any[] = [];
      let scanEngine = 'Vuls (Simulated)';
      
      // First, try using the Vuls REST API service
      try {
        console.log('Checking if Vuls service is available...');
        const isVulsServiceAvailable = await vulsRestClient.isAvailable();
        
        if (isVulsServiceAvailable) {
          console.log('Vuls service is available, using it for scanning...');
          
          // Get the SSH key path for this server
          const sshKeyPath = path.join(process.cwd(), 'ssh-keys', 'id_rsa');
          console.log(`Using SSH key at: ${sshKeyPath}`);
          
          // Extract username from server info
          const username = server.username || 'root';
          console.log(`Using username: ${username} for server ${server.hostname}`);
          
          // Generate Vuls configuration
          console.log('Generating Vuls configuration...');
          const configPath = await vulsRestClient.generateConfig({
            hostname: server.hostname,
            port: server.port || 22,
            username: username,
            sshKeyPath: sshKeyPath,
            ipAddress: server.ipAddress
          });
          console.log(`Generated config at: ${configPath}`);
          
          // Run scan with Vuls service
          console.log('Running Vuls service scan...');
          vulnerabilities = await vulsRestClient.runScan(configPath);
          scanEngine = 'Vuls (Service)';
          
          console.log(`Vuls service scan completed with ${vulnerabilities.length} vulnerabilities found`);
        } else if (this.useDockerWhenAvailable) {
          // If Vuls service is not available, try Docker-based scan
          console.log('Vuls service not available, trying Docker-based scan...');
          const isDockerAvailable = await dockerVulsScanner.isDockerAvailable();
          
          if (isDockerAvailable) {
            // Get the SSH key path for this server
            const sshKeyPath = path.join(process.cwd(), 'ssh-keys', 'id_rsa');
            
            // Extract username from server info
            const username = server.username || 'root';
            
            // Generate Vuls configuration
            const configFile = await dockerVulsScanner.generateVulsConfig({
              id: server.id,
              name: server.name,
              hostname: server.hostname,
              username: username
            }, sshKeyPath);
            
            // Run the Docker-based Vuls scan
            console.log('Running Docker-based Vuls scan...');
            const resultPath = await dockerVulsScanner.runScan(configFile);
            
            // Parse results
            vulnerabilities = await dockerVulsScanner.parseResults(resultPath);
            scanEngine = 'Vuls (Docker)';
            
            console.log(`Docker-based scan completed with ${vulnerabilities.length} vulnerabilities found`);
          } else {
            // Neither Vuls service nor Docker available, use simulation
            console.log('Neither Vuls service nor Docker is available, using simulated scan');
            vulnerabilities = await this.runSimulatedScan(server);
          }
        } else {
          // Docker fallback not enabled, use simulation
          console.log('Docker fallback not enabled, using simulated scan');
          vulnerabilities = await this.runSimulatedScan(server);
        }
      } catch (error) {
        console.error('Error using Vuls service, falling back to simulated scan:', error);
        vulnerabilities = await this.runSimulatedScan(server);
      }
      
      // Save vulnerabilities to database
      for (const vuln of vulnerabilities) {
        const dbVuln = { ...vuln, scanId: scan.id };
        await storage.createVulnerability(dbVuln);
      }
      
      // Update the scan record with counts
      const counts = this.calculateSeverityCounts(vulnerabilities);
      await storage.updateVulnerabilityScan(scan.id, { 
        ...counts,
        status: 'success'
      });
      
      // Update task status
      await storage.updateTask(task.id, { 
        status: 'success',
        completedAt: new Date(),
        output: JSON.stringify({
          message: 'Vulnerability scan completed successfully',
          timestamp: new Date().toISOString(),
          vulnerabilityCounts: counts,
          scanEngine
        })
      });
      
      console.log(`Vulnerability scan completed for server ${server.name} with ${vulnerabilities.length} vulnerabilities found`);
      
    } catch (error: any) {
      console.error('Vulnerability scan error:', error);
      
      // Update scan status
      await storage.updateVulnerabilityScan(scan.id, { 
        status: 'failed',
        errorMessage: error.message || 'Unknown error during vulnerability scan'
      });
      
      // Update task status
      await storage.updateTask(task.id, { 
        status: 'failed',
        completedAt: new Date(),
        output: JSON.stringify({
          error: error.message || 'Unknown error',
          timestamp: new Date().toISOString()
        })
      });
    }
  }
  
  /**
   * Run the simulated Vuls scan as a fallback
   */
  private async runSimulatedScan(server: any): Promise<any[]> {
    // Connect to the server using SSH
    const ssh = await sshManager.connectToServer(server.id);
    
    // Prepare the server for scanning
    const serverDetails = {
      id: server.id,
      name: server.name,
      hostname: server.hostname
    };
    
    await vulsIntegration.prepareServer(ssh, serverDetails);
    
    // Generate Vuls configuration
    const configFile = await vulsIntegration.generateVulsConfig(serverDetails);
    
    // Run the simulated Vuls scan
    return await vulsIntegration.runVulsScan(ssh, serverDetails, configFile);
  }
  
  /**
   * Calculate severity counts for the scan summary
   */
  private calculateSeverityCounts(vulnerabilities: any[]): { 
    lowCount: number, 
    mediumCount: number, 
    highCount: number, 
    criticalCount: number 
  } {
    return {
      lowCount: vulnerabilities.filter(v => v.severity === 'low').length,
      mediumCount: vulnerabilities.filter(v => v.severity === 'medium').length,
      highCount: vulnerabilities.filter(v => v.severity === 'high').length,
      criticalCount: vulnerabilities.filter(v => v.severity === 'critical').length
    };
  }
}

export const vulnerabilityScanner = new VulnerabilityScanner();