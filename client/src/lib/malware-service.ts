import { apiRequest } from './queryClient';

/**
 * Start a malware scan on a server
 * @param serverId Server ID to scan
 * @param options Scan options
 * @returns Promise with scan result
 */
export async function startMalwareScan(serverId: number, options: { scanDirectory?: string, scheduled?: boolean } = {}) {
  const res = await apiRequest('POST', `/api/servers/${serverId}/malware-scan`, options);
  return await res.json();
}

/**
 * Get all malware scans, optionally filtered by server
 * @param serverId Optional server ID to filter by
 * @returns Promise with scan results
 */
export async function getMalwareScans(serverId?: number) {
  const queryParams = serverId ? `?serverId=${serverId}` : '';
  const res = await apiRequest('GET', `/api/malware-scans${queryParams}`);
  return await res.json();
}

/**
 * Get a specific malware scan by ID
 * @param scanId Scan ID
 * @returns Promise with scan details
 */
export async function getMalwareScan(scanId: number) {
  const res = await apiRequest('GET', `/api/malware-scans/${scanId}`);
  return await res.json();
}

/**
 * Get threats for a specific malware scan
 * @param scanId Scan ID
 * @returns Promise with threats list
 */
export async function getMalwareThreats(scanId: number) {
  const res = await apiRequest('GET', `/api/malware-scans/${scanId}/threats`);
  return await res.json();
}

/**
 * Get malware scan for a specific task
 * @param taskId Task ID
 * @returns Promise with scan details
 */
export async function getMalwareScanByTask(taskId: number) {
  const res = await apiRequest('GET', `/api/tasks/${taskId}/malware-scan`);
  return await res.json();
}

/**
 * Get scan status display text
 * @param status Scan status
 * @returns Status display text
 */
export function getScanStatusText(status: string) {
  switch (status) {
    case 'queued':
      return 'Queued';
    case 'running':
      return 'Running';
    case 'success':
      return 'Completed';
    case 'failed':
      return 'Failed';
    default:
      return status.charAt(0).toUpperCase() + status.slice(1);
  }
}

/**
 * Get scan status color for UI
 * @param status Scan status
 * @returns CSS color class
 */
export function getScanStatusColor(status: string) {
  switch (status) {
    case 'queued':
      return 'text-blue-500';
    case 'running':
      return 'text-amber-500';
    case 'success':
      return 'text-green-600';
    case 'failed':
      return 'text-red-600';
    default:
      return 'text-gray-500';
  }
}

/**
 * Get threat category display information
 * @param category Threat category
 * @returns Object with display text and color
 */
export function getThreatCategoryInfo(category: string) {
  switch (category) {
    case 'virus':
      return { text: 'Virus', color: 'text-red-600' };
    case 'trojan':
      return { text: 'Trojan', color: 'text-orange-600' };
    case 'spyware':
      return { text: 'Spyware', color: 'text-amber-600' };
    case 'ransomware':
      return { text: 'Ransomware', color: 'text-red-700' };
    case 'rootkit':
      return { text: 'Rootkit', color: 'text-red-800' };
    case 'backdoor':
      return { text: 'Backdoor', color: 'text-purple-600' };
    case 'other':
    default:
      return { text: 'Other Malware', color: 'text-gray-600' };
  }
}

/**
 * Get a summary of the latest scan for each server
 * @returns Promise with array of latest scans per server
 */
export async function getLatestMalwareScansPerServer() {
  const allScans = await getMalwareScans();
  const serverMap = new Map();
  
  // Group scans by server and keep the latest
  for (const scan of allScans) {
    const existingScan = serverMap.get(scan.serverId);
    
    if (!existingScan || new Date(scan.scanDate) > new Date(existingScan.scanDate)) {
      serverMap.set(scan.serverId, scan);
    }
  }
  
  return Array.from(serverMap.values());
}

/**
 * Get chart data for malware scans across all servers
 * @returns Promise with chart data
 */
export async function getMalwareChartData() {
  const latestScans = await getLatestMalwareScansPerServer();
  const threatsByCategory = new Map<string, number>();
  
  // Initialize all categories with zero
  const categories = ['virus', 'trojan', 'spyware', 'ransomware', 'rootkit', 'backdoor', 'other'];
  for (const category of categories) {
    threatsByCategory.set(category, 0);
  }
  
  // Count all threats by category
  for (const scan of latestScans) {
    if (scan.status === 'success') {
      // Fetch threats for this scan
      const threats = await getMalwareThreats(scan.id);
      
      // Count threats by category
      for (const threat of threats) {
        const category = threat.category || 'other';
        const count = threatsByCategory.get(category) || 0;
        threatsByCategory.set(category, count + 1);
      }
    }
  }
  
  // Format for chart
  return {
    labels: categories.map(c => getThreatCategoryInfo(c).text),
    datasets: [
      {
        data: categories.map(c => threatsByCategory.get(c) || 0),
        backgroundColor: [
          '#dc2626', // red-600 (virus)
          '#ea580c', // orange-600 (trojan)
          '#d97706', // amber-600 (spyware)
          '#b91c1c', // red-700 (ransomware)
          '#991b1b', // red-800 (rootkit)
          '#9333ea', // purple-600 (backdoor)
          '#4b5563', // gray-600 (other)
        ],
      },
    ],
  };
}